package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"go/scanner"
	"go/token"
	"io"
	"io/ioutil"
	"strings"
	"text/template"
	"unicode"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/internal/btf"
)

const ebpfModule = "github.com/cilium/ebpf"

const commonRaw = `// Code generated by bpf2go; DO NOT EDIT.
{{- range .Tags }}
// +build {{ . }}
{{- end }}

package {{ .Package }}

import (
	"bytes"
	"errors"
	"fmt"
	"io"

	"{{ .Module }}"
)

{{- if .Types }}
{{- range $type := .Types }}
{{ $.TypeDeclaration (index $.TypeNames $type) $type }}

{{ end }}
{{- end }}

// {{ .Name.Constants }} contains all constants used by {{ .Name }}.
//
// It only contains global, non-static constants and may be empty.
{{- if .Constants }}
{{ $.TypeDeclaration .Name.Constants .Constants }}
{{- else }}
type {{ .Name.Constants }} struct {}
{{- end }}

// {{ .Name.Load }} returns the embedded CollectionSpec for {{ .Name }}.
func {{ .Name.Load }}() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader({{ .Name.Bytes }})
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load {{ .Name }}: %w", err)
	}

	return spec, err
}

// {{ .Name.LoadObjects }} loads {{ .Name }} and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//     *{{ .Name.Objects }}
//     *{{ .Name.Programs }}
//     *{{ .Name.Maps }}
//
// You can rewrite constants by supplying a non-nil consts argument.
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func {{ .Name.LoadObjects }}(obj interface{}, consts *{{ .Name.Constants }}, opts *ebpf.CollectionOptions) error {
	spec, err := {{ .Name.Load }}()
	if err != nil {
		return err
	}

	if consts != nil {
		if spec.Maps[".rodata"] == nil {
			return errors.New("can't replace constants: missing .rodata section")
		}
		spec.Maps[".rodata"].Contents = []ebpf.MapKV{
			{Key: uint32(0), Value: consts},
		}
	}

	return spec.LoadAndAssign(obj, opts)
}

// {{ .Name.Specs }} contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type {{ .Name.Specs }} struct {
	{{ .Name.ProgramSpecs }}
	{{ .Name.MapSpecs }}
}

// {{ .Name.Specs }} contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type {{ .Name.ProgramSpecs }} struct {
{{- range $name, $id := .Programs }}
	{{ $id }} *ebpf.ProgramSpec {{ tag $name }}
{{- end }}
}

// {{ .Name.MapSpecs }} contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type {{ .Name.MapSpecs }} struct {
{{- range $name, $id := .Maps }}
	{{ $id }} *ebpf.MapSpec {{ tag $name }}
{{- end }}
}

// {{ .Name.Objects }} contains all objects after they have been loaded into the kernel.
//
// It can be passed to {{ .Name.LoadObjects }} or ebpf.CollectionSpec.LoadAndAssign.
type {{ .Name.Objects }} struct {
	{{ .Name.Programs }}
	{{ .Name.Maps }}
}

func (o *{{ .Name.Objects }}) Close() error {
	return {{ .Name.CloseHelper }}(
		&o.{{ .Name.Programs }},
		&o.{{ .Name.Maps }},
	)
}

// {{ .Name.Maps }} contains all maps after they have been loaded into the kernel.
//
// It can be passed to {{ .Name.LoadObjects }} or ebpf.CollectionSpec.LoadAndAssign.
type {{ .Name.Maps }} struct {
{{- range $name, $id := .Maps }}
	{{ $id }} *ebpf.Map {{ tag $name }}
{{- end }}
}

func (m *{{ .Name.Maps }}) Close() error {
	return {{ .Name.CloseHelper }}(
{{- range $id := .Maps }}
		m.{{ $id }},
{{- end }}
	)
}

// {{ .Name.Programs }} contains all programs after they have been loaded into the kernel.
//
// It can be passed to {{ .Name.LoadObjects }} or ebpf.CollectionSpec.LoadAndAssign.
type {{ .Name.Programs }} struct {
{{- range $name, $id := .Programs }}
	{{ $id }} *ebpf.Program {{ tag $name }}
{{- end }}
}

func (p *{{ .Name.Programs }}) Close() error {
	return {{ .Name.CloseHelper }}(
{{- range $id := .Programs }}
		p.{{ $id }},
{{- end }}
	)
}

func {{ .Name.CloseHelper }}(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
var {{ .Name.Bytes }} = []byte("{{ .Bytes }}")

`

var (
	tplFuncs = map[string]interface{}{
		"tag": tag,
	}
	commonTemplate = template.Must(template.New("common").Funcs(tplFuncs).Parse(commonRaw))
)

type templateName string

func (n templateName) maybeExport(str string) string {
	if token.IsExported(string(n)) {
		return toUpperFirst(str)
	}

	return str
}

func (n templateName) Bytes() string {
	return "_" + toUpperFirst(string(n)) + "Bytes"
}

func (n templateName) Specs() string {
	return string(n) + "Specs"
}

func (n templateName) ProgramSpecs() string {
	return string(n) + "ProgramSpecs"
}

func (n templateName) MapSpecs() string {
	return string(n) + "MapSpecs"
}

func (n templateName) Load() string {
	return n.maybeExport("load" + toUpperFirst(string(n)))
}

func (n templateName) LoadObjects() string {
	return n.maybeExport("load" + toUpperFirst(string(n)) + "Objects")
}

func (n templateName) Objects() string {
	return string(n) + "Objects"
}

func (n templateName) Maps() string {
	return string(n) + "Maps"
}

func (n templateName) Programs() string {
	return string(n) + "Programs"
}

func (n templateName) Constants() string {
	return string(n) + "Constants"
}

func (n templateName) CloseHelper() string {
	return "_" + toUpperFirst(string(n)) + "Close"
}

type outputArgs struct {
	pkg   string
	ident string
	tags  []string
	obj   io.Reader
	out   io.Writer
}

func output(args outputArgs) error {
	obj, err := ioutil.ReadAll(args.obj)
	if err != nil {
		return fmt.Errorf("read object file contents: %s", err)
	}

	spec, err := ebpf.LoadCollectionSpecFromReader(bytes.NewReader(obj))
	if err != nil {
		return fmt.Errorf("can't load BPF from ELF: %s", err)
	}

	maps := make(map[string]string)
	for name := range spec.Maps {
		if strings.HasPrefix(name, ".") {
			// Skip .rodata, .data, .bss, etc. sections
			continue
		}

		maps[name] = identifier(name)
	}

	programs := make(map[string]string)
	for name := range spec.Programs {
		programs[name] = identifier(name)
	}

	var constants *btf.Datasec
	if rodata := spec.Maps[".rodata"]; rodata != nil {
		constants, _ = btf.MapValue(rodata.BTF).(*btf.Datasec)
	}

	var (
		namedTypes []btf.NamedType
		names      map[btf.Type]string
	)
	if constants != nil {
		namedTypes, names, err = findTypes(args.ident, constants)
		if err != nil {
			return err
		}
	}

	gf := btf.NewGoFormatter(names)
	gf.Identifier = identifier

	ctx := struct {
		*btf.GoFormatter
		Module    string
		Package   string
		Tags      []string
		Name      templateName
		Maps      map[string]string
		Programs  map[string]string
		Constants *btf.Datasec
		Types     []btf.NamedType
		TypeNames map[btf.Type]string
		Bytes     string
	}{
		gf,
		ebpfModule,
		args.pkg,
		args.tags,
		templateName(args.ident),
		maps,
		programs,
		constants,
		namedTypes,
		names,
		binaryString(obj),
	}

	var buf bytes.Buffer
	if err := commonTemplate.Execute(&buf, &ctx); err != nil {
		return fmt.Errorf("can't generate types: %s", err)
	}

	return writeFormatted(buf.Bytes(), args.out)
}

// globalVarTypes returns the types of global non-static variables section.
//
// Each type is only returned once.
func globalVarTypes(section *btf.Datasec) ([]btf.Type, error) {
	var types []btf.Type
	seen := make(map[btf.Type]bool)
	for _, vsi := range section.Vars {
		v := vsi.Type.(*btf.Var)

		if v.Linkage != btf.GlobalVar {
			continue
		}

		typ, err := btf.SkipQualifiers(v.Type)
		if err != nil {
			return nil, err
		}

		if seen[typ] {
			continue
		}

		types = append(types, typ)
		seen[typ] = true
	}
	return types, nil
}

// namedTypes returns all types that have a name.
//
// Types and typedefs are skipped if a Go primitive exists.
func namedTypes(types []btf.Type) ([]btf.NamedType, error) {
	var named []btf.NamedType
	for _, typ := range types {
		namedTyp, ok := typ.(btf.NamedType)
		if !ok {
			continue
		}

		underlying, err := btf.SkipQualifiersAndTypedefs(namedTyp)
		if err != nil {
			return nil, err
		}

		if _, ok := underlying.(*btf.Int); ok {
			// Don't redefine ints, we want to use the builtin types.
			continue
		}

		if name := namedTyp.TypeName(); name != "" {
			named = append(named, namedTyp)
		}
	}
	return named, nil
}

func findTypes(prefix string, section *btf.Datasec) ([]btf.NamedType, map[btf.Type]string, error) {
	types, err := globalVarTypes(section)
	if err != nil {
		return nil, nil, err
	}

	predeclared, err := namedTypes(types)
	if err != nil {
		return nil, nil, err
	}

	names := make(map[btf.Type]string)
	for _, typ := range predeclared {
		names[typ] = prefix + identifier(typ.TypeName())
	}

	return predeclared, names, nil
}

func binaryString(buf []byte) string {
	var builder strings.Builder
	for _, b := range buf {
		builder.WriteString(`\x`)
		builder.WriteString(fmt.Sprintf("%02x", b))
	}
	return builder.String()
}

func writeFormatted(src []byte, out io.Writer) error {
	formatted, err := format.Source(src)
	if err == nil {
		_, err = out.Write(formatted)
		return err
	}

	var el scanner.ErrorList
	if !errors.As(err, &el) {
		return err
	}

	var nel scanner.ErrorList
	for _, err := range el {
		if !err.Pos.IsValid() {
			nel = append(nel, err)
			continue
		}

		buf := src[err.Pos.Offset:]
		nl := bytes.IndexRune(buf, '\n')
		if nl == -1 {
			nel = append(nel, err)
			continue
		}

		err.Msg += ": " + string(buf[:nl])
		nel = append(nel, err)
	}

	return nel
}

func identifier(str string) string {
	prev := rune(-1)
	return strings.Map(func(r rune) rune {
		// See https://golang.org/ref/spec#Identifiers
		switch {
		case unicode.IsLetter(r):
			if prev == -1 {
				r = unicode.ToUpper(r)
			}

		case r == '_':
			switch {
			// The previous rune was deleted, or we are at the
			// beginning of the string.
			case prev == -1:
				fallthrough

			// The previous rune is a lower case letter or a digit.
			case unicode.IsDigit(prev) || (unicode.IsLetter(prev) && unicode.IsLower(prev)):
				// delete the current rune, and force the
				// next character to be uppercased.
				r = -1
			}

		case unicode.IsDigit(r):

		default:
			// Delete the current rune. prev is unchanged.
			return -1
		}

		prev = r
		return r
	}, str)
}

func tag(str string) string {
	return "`ebpf:\"" + str + "\"`"
}
